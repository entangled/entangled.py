.\" Automatically generated by Pandoc 3.1.11.1
.\"
.TH "entangled" "1" "" "version 2.4" "User Commands"
.SH NAME
Entangled \- Your literate programming toolkit.
.SH SYNOPSIS
\f[CR]entangled [options] [command] [arguments]...\f[R]
.SH DESCRIPTION
Entangled helps you write Literate Programs in Markdown.
You put all your code inside Markdown code blocks.
Entangled automatically extracts the code and writes it to more
traditional source files.
You can then edit these generated files, and the changes are being fed
back to the Markdown.
.SH OPTIONS
.TP
\f[CR]\-\-help\f[R]
Show the help message and exit.
.TP
\f[CR]\-v, \-\-version\f[R]
Show version and exit.
.TP
\f[CR]\-d, \-\-debug\f[R]
Print debug messages.
.SH COMMANDS
Each command has its own arguments and flags that can be inspected using
\f[CR]entangled <command> \-\-help\f[R].
.TP
\f[CR]brei <target>\f[R]
Build a Brei workflow target.
See section BREI
.TP
\f[CR]new <template> <project\-path>\f[R]
Create a new entangled project from a template in the given project
path.
.TP
\f[CR]reset\f[R]
Reset the file database.
.TP
\f[CR]status\f[R]
Print a status overview.
.TP
\f[CR]stitch\f[R]
Stitch code changes back into the documentation.
.TP
\f[CR]sync\f[R]
Automatically detects ifBe smart wether to tangle or stich
.TP
\f[CR]tangle\f[R]
Tangle codes from the documentation.
.TP
\f[CR]watch\f[R]
Keep a loop running, watching for changes in the file system.
.SH WRITING PROGRAMS
Entangled enables a \f[B]documentation first\f[R] approach to
programming.
To write programs using Entangled, you start by writing documentation
and in Markdown and then add code blocks.
The code blocks can be marked with attributes to indicate where code
should be written.
.SS HELLO WORLD
The combined code\-blocks in this example compose a compilable source
code for \[lq]Hello World\[rq].
For didactic reasons we don\[cq]t always give the listing of an entire
source file in one go.
In stead, we use a system of references known as \f[I]noweb\f[R] (after
Ramsey 1994).
.PP
Inside source fragments you may encounter a line with \f[CR]<<...>>\f[R]
marks like,
.IP
.EX
\[ga]\[ga]\[ga] {.cpp file=hello_world.cc}
#include <cstdlib>
#include <iostream>

<<example\-main\-function>>
\[ga]\[ga]\[ga]
.EE
.PP
which is then elsewhere specified.
Order doesn\[cq]t matter,
.IP
.EX
\[ga]\[ga]\[ga] {.cpp #hello\-world}
std::cout << \[dq]Hello, World!\[dq] << std::endl;
\[ga]\[ga]\[ga]
.EE
.PP
So we can reference the \f[CR]<<hello\-world>>\f[R] code block later on.
.IP
.EX
\[ga]\[ga]\[ga] {.cpp #example\-main\-function}
int main(int argc, char **argv)
{
    <<hello\-world>>
}
\[ga]\[ga]\[ga]
.EE
.PP
A definition can be appended with more code as follows (in this case,
order does matter!):
.IP
.EX
\[ga]\[ga]\[ga] {.cpp #hello\-world}
return EXIT_SUCCESS;
\[ga]\[ga]\[ga]
.EE
.PP
These blocks of code can be \f[B]tangled\f[R] into source files.
.SS DEFAULT SYNTAX
The standard syntax is aimed to work well together with Pandoc.
Every code block is delimited with three back ticks.
Added to the opening line is a sequence of space separated \f[B]code
properties\f[R].
These properties align with the CSS attributes that would end up in the
generated HTML.
For those unfamiliar with CSS:
.IP \[bu] 2
\f[CR]#identifier\f[R]; a name prefixed with a \f[CR]#\f[R] (sharp),
identifies the object, only one of these should be present per item
.IP \[bu] 2
\f[CR].class\f[R]; a name prefixed with \f[CR].\f[R] (period), assigns
the object to a class, a object can belong to any number of classes
.IP \[bu] 2
\f[CR]key=value\f[R]; a name suffixed with \f[CR]=\f[R] (equals),
optionally followed by a value, adds any meta\-data attribute to the
object
.PP
The complete syntax of a code block then looks like:
.IP
.EX
\[ga]\[ga]\[ga] {[#<reference>|.<language>|<key>=<value>] ...}
<code> ...
\[ga]\[ga]\[ga]
.EE
.PP
The first class in the code properties is always interpreted to give the
\f[B]programming language\f[R] of the code block.
In Entangled, any code block is one of the following:
.IP \[bu] 2
A \f[B]referable\f[R] block: has exactly one \f[B]reference id\f[R]
(\f[CR]#<reference>\f[R]) and a class giving the language of the code
block (\f[CR].<language>\f[R]).
Example:
.RS 2
.IP
.EX
\[ga]\[ga]\[ga] {.rust #hello\-rust}
println!(\[dq]Hello, Rust!\[dq]);
\[ga]\[ga]\[ga]
.EE
.PP
In some cases you may want to have additional classes to trigger hooks
or a specific filter.
Always the first class is interpreted to identify the language.
.RE
.IP \[bu] 2
A \f[B]file\f[R] block: has a key\-value pair giving the path to the
file (\f[CR]file=<path>\f[R]), absolute or relative to the directory in
which \f[CR]entangled\f[R] runs.
Again, there should be one class giving the language of the block
(\f[CR].<language>\f[R]).
Example:
.RS 2
.IP
.EX
\[ga]\[ga]\[ga] {.rust file=src/main.rs}
fn main() {
   <<hello\-rust>>
}
\[ga]\[ga]\[ga]
.EE
.PP
The identifier in a file block is optional.
If it is left out, the identifier will silently be taken to be the file
name.
.RE
.IP \[bu] 2
An \f[B]ignored\f[R] block: anything not matching the previous two.
.SS TANGLED CODE
Entangled recognizes three parameters for every code block.
These parameters are extracted from an opening line may be configured
using regular expressions.
Formally, every code block has three properties:
.IP \[bu] 2
\f[CR]Language\f[R]
.IP \[bu] 2
\f[CR]Identifier\f[R]
.IP \[bu] 2
\f[CR]Optional Filename\f[R]
.PP
Entangled should tangle your code following these rules:
.IP "1." 3
If an \f[B]identifier\f[R] is repeated the contents of the code blocks
is concatenated in the order that they appear in the Markdown.
If an identifier appears in multiple files, the order is dependent on
the order by which the files appear in the configuration, or if they
result from a glob\-pattern expansion, alphabetical order.
.IP "2." 3
\f[B]Noweb references\f[R] are \f[B]expanded\f[R].
A noweb reference in Entangled should occupy a single line of code by
itself, and is enclosed with double angle brackets, and maybe indented
with white space.
Space at the end of the line is ignored.
.RS 4
.IP
.EX
+\-\-\- indentation \-\-\-+\-\-\- reference  \-\-\-+\-\-\- possible space \-\-\-+
                    <<noweb\-reference>>
.EE
.PP
The reference is expanded recursively, after which the indentation is
prefixed to every line in the expanded reference content.
.RE
.IP "3." 3
\f[B]Annotation\f[R]; Expanded and concatenated code blocks are
annotated using comment lines.
These lines should not be touched when editing the generated files.
The default method of annotation follows an opening comment with
\f[CR]\[ti]\[rs]\[ti] begin <<filename#identifier>>[n]\f[R], and a
closing comment with \f[CR]\[ti]\[rs]\[ti] end\f[R].
For example
.RS 4
.IP
.EX
// \[ti]\[rs]\[ti] begin <<lit/index.md|main>>[1]
println!(\[dq]hello\[dq]);
// \[ti]\[rs]\[ti] end
.EE
.RE
.SH CONFIGURATION
Global configuration is loaded from \f[CR]entangled.toml\f[R] in the
current working directory, or from the YAML header of the Markdown file,
if there is only one input file.
In the case of multiple input files, the YAML header is local to that
input file.
.PP
Configuration should match the following scheme:
.TP
\f[CR]version\f[R]
(\f[CR]string\f[R]) the minimum version of Entangled.
.TP
\f[CR]style\f[R]
(\f[CR]string\f[R]: \f[CR]default\f[R] | \f[CR]basic\f[R]) (default:
\f[CR]default\f[R]) a configuration preset.
See STYLES.
.TP
\f[CR]languages\f[R]
(\f[CR]list[Language]\f[R]) additional language settings.
.TP
\f[CR]markers\f[R]
(\f[CR]Markers\f[R]) override marker expressions for extracting code
blocks.
.TP
\f[CR]watch_list\f[R]
(\f[CR]list[string]\f[R]) sets a list of glob patterns for files to
read.
.TP
\f[CR]ignore_list\f[R]
(\f[CR]list[string]\f[R]) sets a list of glob patterns to exclude from
reading.
.TP
\f[CR]annotation\f[R]
(\f[CR]string\f[R]: \f[CR]standard\f[R] | \f[CR]naked\f[R] |
\f[CR]supplemented\f[R]) sets the method for annotating tangled files.
.TP
\f[CR]annotation_format\f[R]
(\f[CR]string\f[R]) set a format string for \f[CR]supplemented\f[R]
annotation (not yet implemented).
.TP
\f[CR]use_line_directives\f[R]
(\f[CR]bool\f[R]) wether to include line directives to point compilers
to the Markdown input source (not yet implemented).
.TP
\f[CR]namespace\f[R]
(\f[CR]string\f[R]) set the namespace for the current input file.
Namespaces are separated with double colons \f[CR]::\f[R].
.TP
\f[CR]namespace_default\f[R]
(\f[CR]string\f[R]: \f[CR]global\f[R] | \f[CR]private\f[R]) if the
namespace is absent, this controls the scope of code block identifiers.
.TP
\f[CR]hooks\f[R]
(\f[CR]list[string]\f[R]) set the hooks used.
Prepend a hook name with a tilde \f[CR]\[ti]\f[R] to disable a hook
locally.
.TP
\f[CR]hook\f[R]
(\f[CR]object\f[R]) additional settings for enabled hooks.
.TP
\f[CR]brei\f[R]
(\f[CR]Program\f[R]) create more Brei targets that are not listed in
code blocks.
The \f[CR]Program\f[R] API is specified by the \f[CR]brei\f[R] package.
.SS LANGUAGE
We can configure how a language is treated by setting comment
characters.
For example:
.IP
.EX
[[languages]]
name = \[dq]Java\[dq]
identifiers = [\[dq]java\[dq]]
comment = { open = \[dq]//\[dq] }

# Some languages have comments that are not terminated by
# newlines, like XML or CSS.
[[languages]]
name = \[dq]XML\[dq]
identifiers = [\[dq]xml\[dq], \[dq]html\[dq], \[dq]svg\[dq]]
comment = { open = \[dq]<!\-\-\[dq], close = \[dq]\-\->\[dq] }
.EE
.TP
\f[CR]name\f[R]
(\f[CR]string\f[R]) a unique name for the language.
.TP
\f[CR]identifiers\f[R]
(\f[CR]list[string]\f[R]) a set of identifiers that are admissable as
language classes for a code block using this language.
.TP
\f[CR]comment\f[R]
(\f[CR]object[open: string, close: string = \[dq]\[dq]]\f[R]) how to
write comments in this language.
.SS MARKERS
This configures how code blocks are detected.
.TP
\f[CR]open\f[R]
(\f[CR]string\f[R]) opening regex for a code block.
Python\[cq]s regex engine supports named groups using
\f[CR](?P<name>...)\f[R] syntax.
This expression should contain an \f[CR]indent\f[R] group and a
\f[CR]properties\f[R] group.
The returned indentation should contain only spaces, and
\f[CR]properties\f[R] should at the minimum have the language identifier
for the code block.
.TP
\f[CR]close\f[R]
(\f[CR]string\f[R]) closing regex for a code block.
This should contain a named pattern group \f[CR]indent\f[R].
.SH STYLES
There are two configuration styles available: \f[CR]default\f[R] and
\f[CR]basic\f[R].
.SS DEFAULT
The default is to read code blocks with three back\-tics and attributes
grouped in curly braces.
For example:
.IP
.EX
This is a code block:

\[ga]\[ga]\[ga] {.c #print\-hello}
printf(\[dq]Hello, World!\[dq]);
\[ga]\[ga]\[ga]
.EE
.SS BASIC
The basic style is less expressive but has better compatability with
most standard Markdown syntaxes like Github.In this style only the
language identifier is given after three back\-tics.
Other attributes are passed using the \f[CR]quarto_attributes\f[R] hook.
For example:
.IP
.EX
This is a code block:

\[ga]\[ga]\[ga]c
//| id: print\-hello
printf(\[dq]Hello, World!\[dq]);
\[ga]\[ga]\[ga]
.EE
.SH HOOKS
.SS BREI
Entangled has an integrated build system called Brei, that can be used
to produce figures or other artifacts.
Targets and their dependencies can be specified in code blocks using the
\f[CR]brei\f[R] hook.
These tasks may depend on one another.
Brei will run these when dependencies are newer than the target.
Execution is lazy and in parallel.
Brei supports:
.IP \[bu] 2
Running tasks by passing a script to any configured interpreter,
e.g.\ Bash, Python, Lua etc.
.IP \[bu] 2
Redirecting \f[CR]stdout\f[R] or \f[CR]stdin\f[R] to or from files.
.IP \[bu] 2
Defining so called \[lq]phony\[rq] targets.
.IP \[bu] 2
Define \f[CR]template\f[R] for programmable reuse.
.IP \[bu] 2
\f[CR]include\f[R] other Brei files, even ones that need to be generated
by another \f[CR]task\f[R].
.IP \[bu] 2
Variable substitution, including writing \f[CR]stdout\f[R] to variables.
.PP
Brei is available as a separate package, see \c
.UR https://entangled.github.io/brei
the Brei documentation
.UE \c
\&.
.SS Examples
To write out \[lq]Hello, World!\[rq] to a file \f[CR]msg.txt\f[R], we
may do the following,
.IP
.EX
[[task]]
stdout = \[dq]secret.txt\[dq]
language = \[dq]Python\[dq]
script = \[dq]\[dq]\[dq]
print(\[dq]Uryyb, Jbeyq!\[dq])
\[dq]\[dq]\[dq]
.EE
.PP
To have this message decoded define a pattern,
.IP
.EX
[pattern.rot13]
stdout = \[dq]{stdout}\[dq]
stdin = \[dq]{stdin}\[dq]
language = \[dq]Bash\[dq]
script = \[dq]\[dq]\[dq]
tr a\-zA\-Z n\-za\-mN\-ZA\-M
\[dq]\[dq]\[dq]

[[call]]
pattern = \[dq]rot13\[dq]
  [call.args]
  stdin = \[dq]secret.txt\[dq]
  stdout = \[dq]msg.txt\[dq]
.EE
.PP
To define a phony target \[lq]all\[rq],
.IP
.EX
[[task]]
name = \[dq]all\[dq]
requires = [\[dq]msg.txt\[dq]]
.EE
.SS The Brei hook
The following example uses both \f[CR]brei\f[R] and
\f[CR]quatro_attributes\f[R] hooks.
To add a Brei task, tag a code block with the \f[CR].task\f[R] class.
.IP
.EX
First we generate some data.

\[ga]\[ga]\[ga] {.python #some\-functions}
# define some functions
\[ga]\[ga]\[ga]

Now we show what that data would look like:

\[ga]\[ga]\[ga] {.python .task}
#| description: Generate data
#| creates: data/data.npy

<<some\-functions>>

# generate and save data
\[ga]\[ga]\[ga]

Then we plot in another task.

\[ga]\[ga]\[ga] {.python .task}
#| description: Plot data
#| creates: docs/fig/plot.svg
#| requires: data/data.npy
#| collect: figures

# load data and plot
\[ga]\[ga]\[ga]
.EE
.PP
The \f[CR]collect\f[R] attribute tells the Brei hook to add the
\f[CR]docs/fig/plot.svg\f[R] target to the \f[CR]figures\f[R]
collection.
All figures can then be rendered as follows, having in
\f[CR]entangled.toml\f[R]
.IP
.EX
version = \[dq]2.0\[dq]
watch_list = [\[dq]docs/**/*.md\[dq]]
hooks = [\[dq]quatro_attributes\[dq], \[dq]brei\[dq]]

[brei]
include = [\[dq].entangled/tasks.json\[dq]]
.EE
.PP
And run
.IP
.EX
entangled brei figures
.EE
.PP
You can use \f[CR]${variable}\f[R] syntax inside Brei tasks just as you
would in a stand\-alone Brei script.
.SS QUARTO ATTRIBUTES
Sometimes using the \f[CR]build\f[R] hook (or the \f[CR]brei\f[R] hook,
see below), leads to long header lines.
It is then better to specify attributes in a header section of your
code.
The Quarto project came up with a syntax, having the header be indicated
by a comment with a vertical bar, e.g.\ \f[CR]#|\f[R] or \f[CR]//|\f[R]
etc.
The \f[CR]quarto_attributes\f[R] hook reads those attributes and adds
them to the properties of the code block.
.PP
Example with the \f[CR]brei\f[R] hook:
.IP
.EX
\[ga]\[ga]\[ga] {.python .task}
#| description: Draw a triangle
#| creates: docs/fig/triangle.svg
#| collect: figures
from matplotlib import pyplot as plt
plt.plot([[\-1, \-0.5], [1, \-0.5], [0, 1], [\-1, \-0.5]])
plt.savefig(\[dq]docs/fig/triangle.svg\[dq])
\[ga]\[ga]\[ga]

![](fig/triangle.svg)
.EE
.PP
Using these attributes it is possible to write in Entangled using
completely standard Markdown syntax.
.PP
The \f[CR]id\f[R] attribute is reserved for the code\[cq]s identifier
(normally indicated with \f[CR]#\f[R]) and the \f[CR]classes\f[R]
attribute can be used to indicate a list of classes in addition to the
language class already given.
.SS REPL (experimental)
The \f[CR]repl\f[R] hook enables running code blocks in REPL sessions.
The hook extracts these code blocks into a separate JSON session file
that can be evaluated using the \f[CR]repl\-session\f[R] tool \c
.UR https://entangled.github.io/repl-session
.UE \c
\&.
The output needs to be processed by the documentation rendering system.
The \f[CR]mkdocs\-entangled\-plugin\f[R] package handles \f[CR]repl\f[R]
sessions and integrates the output into the rendered HTML.
.SS SHEBANG
If a code block starts with \f[CR]#!...\f[R] on the first line.
This line is brought to the top of the tangled file.
Together with the use of a \f[CR]mode\f[R] attribute, this enables
coding executable scripts in Entangled.
Example:
.IP
.EX
A first Bash script:

\[ga]\[ga]\[ga] {.bash file=cowsay mode=0755}
#!/bin/bash
echo \[dq]Mooo!\[dq]
\[ga]\[ga]\[ga]
.EE
.SS SPDX_LICENSE
If a code block starts with a line containing the string
\[lq]SPDX\-License\-Identifier\[rq].
That line is put above the first annotation comment, similar to the
\f[CR]shebang\f[R] hook.
.SH BUGS
Bugs can be reported at \c
.UR https://github.com/entangled/entangled.py/issues
github.com/entangled/entangled.py/issues
.UE \c
\&.
