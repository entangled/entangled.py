"""
The `build` hook collects code blocks that are tagged with the `#build`
identifier and have a `target=` attribute defined.  These code blocks are put
together into a temporary Makefile that is run from the current working
directory.
"""

from __future__ import annotations
from dataclasses import dataclass, field
from pathlib import Path
from subprocess import run, SubprocessError, DEVNULL

from entangled.config.language import Language

from ..properties import Property, get_attribute, get_classes
from ..document import ReferenceId, ReferenceMap, CodeBlock

from .base import HookBase, PrerequisitesFailed

"""
The Makefile is generated with `preamble` as a format string.  The
`.RECIPEPREFIX` is set to `>` , and `target` attributes are collected into an
`all` target.
"""
preamble = """
# This Makefile is generated by Entangled. Modifications will be overwritten.

.PHONY = all

all: {targets}

{rules}
"""

EXEC_CMDS = {
    "Python": "python {script}",
    "Bash": "bash {script}",
    "Julia": "julia -O0 --project=. {script}",
}


class Hook(HookBase):
    @dataclass
    class Config(HookBase.Config):
        runners: dict[str, str] = field(default_factory=dict)

        def __post_init__(self):
            for k, v in EXEC_CMDS.items():
                if k not in self.runners:
                    self.runners[k] = v

    @dataclass
    class Recipe:
        target: str
        dependencies: list[str]
        language: Language
        scriptfile: str

        def to_makefile(self, config: Hook.Config):
            dep_str = " ".join(self.dependencies)
            exec_cmd = config.runners[self.language.name].format(script=self.scriptfile)
            return f"{self.target}: {self.scriptfile} {dep_str}\n" f"\t{exec_cmd}"

    def __init__(self, config: Hook.Config):
        self.recipes: list[Hook.Recipe] = []
        self.config = config

    def check_prerequisites(self):
        """Check that `make` is installed."""
        try:
            run(["make", "--version"], stdout=DEVNULL)
        except (SubprocessError, FileNotFoundError):
            raise PrerequisitesFailed("GNU Make needs to be installed")

    def condition(self, props: list[Property]):
        """Condition by which a CodeBlock is processed: should have `.build` class
        and `target=` attribute."""
        return (
            "build" in get_classes(props) and get_attribute(props, "target") is not None
        )

    def on_read(self, refs: ReferenceMap, ref: ReferenceId, cb: CodeBlock):
        """Add a CodeBlock's target attribute to the list of targets."""
        target = get_attribute(cb.properties, "target")
        if target is None:
            return

        script_file_name = get_attribute(cb.properties, "file")
        if script_file_name is None:
            script_file_name = f".entangled/build/{ref.name}".replace(":", "_")
            refs.index[script_file_name].append(ref)
            refs.targets.add(script_file_name)

        deps = (get_attribute(cb.properties, "deps") or "").split()
        self.recipes.append(Hook.Recipe(target, deps, cb.language, script_file_name))

    def post_tangle(self, _: ReferenceMap):
        """After all code is tangled: retrieve the build scripts and run it."""
        targets = " ".join([r.target for r in self.recipes])
        makefile = preamble.format(
            targets=targets,
            rules="\n\n".join(r.to_makefile(self.config) for r in self.recipes),
        )
        Path(".entangled/build").mkdir(exist_ok=True, parents=True)
        Path(".entangled/build/Makefile").write_text(makefile)
