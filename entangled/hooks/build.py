"""
The `build` hook collects code blocks that are tagged with the `#build`
identifier and have a `target=` attribute defined.  These code blocks are put
together into a temporary Makefile that is run from the current working
directory.
"""

from __future__ import annotations
from dataclasses import dataclass
from msgspec import field
from pathlib import Path
from subprocess import run, SubprocessError, DEVNULL
import logging
from typing import final, override

from entangled.config.language import Language

from ..properties import Property, get_attribute, get_classes
from ..document import ReferenceId, ReferenceMap, CodeBlock

from .base import HookBase, PrerequisitesFailed

"""
The Makefile is generated with `preamble` as a format string.  The
`.RECIPEPREFIX` is set to `>` , and `target` attributes are collected into an
`all` target.
"""
preamble = """
# This Makefile is generated by Entangled. Modifications will be overwritten.

.PHONY = all

all: {targets}

{rules}
"""

EXEC_CMDS = {
    "Python": "python {script}",
    "Bash": "bash {script}",
    "Julia": "julia -O0 --project=. {script}",
}


@final
class Hook(HookBase):
    class Config(HookBase.Config):
        runners: dict[str, str] = field(default_factory=dict)

        def __post_init__(self):
            for k, v in EXEC_CMDS.items():
                if k not in self.runners:
                    self.runners[k] = v

    @dataclass
    class Recipe:
        target: str
        dependencies: list[str]
        language: Language
        scriptfile: str

        def to_makefile(self, config: Hook.Config):
            dep_str = " ".join(self.dependencies)
            exec_cmd = config.runners[self.language.name].format(script=self.scriptfile)
            return f"{self.target}: {self.scriptfile} {dep_str}\n" + f"\t{exec_cmd}"

    def __init__(self, config: Hook.Config):
        super().__init__(config)
        self.recipes: list[Hook.Recipe] = []
        self.config = config

    @override
    def check_prerequisites(self):
        """Check that `make` is installed."""
        try:
            _ = run(["make", "--version"], stdout=DEVNULL)
        except (SubprocessError, FileNotFoundError):
            raise PrerequisitesFailed("GNU Make needs to be installed")

    @override
    def pre_tangle(self, refs: ReferenceMap):
        """Add a CodeBlock's target attribute to the list of targets."""
        for (ref, cb) in refs.map.items():
            logging.debug("build hook: passing: %s", ref)
            if "build" not in get_classes(cb.properties):
                continue
            target = get_attribute(cb.properties, "target")
            if target is None:
                continue
            if cb.language is None:
                continue

            logging.debug("build hook: target: %s", target)
            script_file_name = get_attribute(cb.properties, "file")
            if script_file_name is None:
                script_file_name = f".entangled/build/{ref.name}".replace(":", "_")
                refs.index[script_file_name].append(ref)
                refs.targets.add(script_file_name)

            deps = [str(s) for s in (get_attribute(cb.properties, "deps") or "").split()]
            self.recipes.append(Hook.Recipe(target, deps, cb.language, script_file_name))

    @override
    def post_tangle(self, refs: ReferenceMap):
        """After all code is tangled: retrieve the build scripts and run it."""
        targets = " ".join([r.target for r in self.recipes])
        makefile = preamble.format(
            targets=targets,
            rules="\n\n".join(r.to_makefile(self.config) for r in self.recipes),
        )
        Path(".entangled/build").mkdir(exist_ok=True, parents=True)
        _ = Path(".entangled/build/Makefile").write_text(makefile)
